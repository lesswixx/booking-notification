# Система записи к врачу с напоминаниями

Запуск:

```bash
docker-compose up --build
```

---



1. **Booking Service**
   
При запуске сразу предзаполняется бд миграцией.

При GET-запросе к /api/slots/{doctorId}, сервис обращается к репозиторию слотов 
и выдаёт все свободные слоты данного врача, отфильтровав помеченные как занятые.

При попытке записаться на приём через POST /api/bookings с JSON, содержащим userId, doctorId и 
slotId, Booking Service сначала читает выбранный слот с блокировкой, чтобы 
исключить одновременное бронирование двумя пользователями. Если слот уже занят, возвращается 
ошибка, в противном случае поле booked устанавливается в true и сохраняется. 

Затем создаётся 
сущность Appointment с привязкой к пользователю, врачу и слоту, сохраняется в таблице appointment, 
где на уровне БД действует уникальное ограничение по slot_id, не дающее записать один и тот же слот дважды.

После успешного сохранения в рамках той же транзакции запускается транзакционный продюсер Kafka — событие 
AppointmentCreatedEvent помещается в топик appointments.created, что гарантирует надёжную доставку и 
согласованность между базой и сообщениями. 

Все ошибки обрабатываются централизованно через 
RestExceptionHandler, возвращая клиенту структуру ApiError с таймстампом, статусом, описанием и 
URL запроса. 

3. **Notification Service**

При старте Notification Service создаёт `TaskScheduler` и запускает инициализацию: 
из таблицы `appointment` через JPA-репозиторий извлекаются все приёмы с датой позже текущего 
времени, и для каждого планируются напоминания. 
  
Подписка на Kafka-топик `appointments.created`
осуществляется через `@KafkaListener`: при получении события `AppointmentCreatedEvent` вызывается метод,
который для нового приёма рассчитывает два времени для напоминаний (за 1 день и за 2 часа до визита) и 
передаёт их в `NotificationScheduler`. Внутри `NotificationScheduler` каждое напоминание проверяет, не
прошло ли уже рассчитанное время; если нет — через `TaskScheduler.schedule(...)` создаётся задача, 
которая при срабатывании вызывает `NotificationService.sendNotification(...)`. 
По умолчанию это реализовано в `LoggingNotificationService`: сообщение с деталями приёма 
(appointmentId, userId, doctorId, visitAt) пишется в отдельный лог-файл `reminders.log`. 
При необходимости логгер можно заменить на отправку SMS или email, реализовав свой `NotificationService`.
Ошибки при обработке событий и планировании задач попадают в стандартный лог сервиса 

---

### Транзакции в Kafka

* Порядок действий: фиксация DB-транзакции → начало Kafka-транзакции → публикация события → коммит Kafka-транзакции
* Обеспечивается «exactly once» доставка сообщений

### Индексы в базе данных

* **idx\_appointment\_date\_time** — ускоряет поиск приёмов по дате
* **idx\_slot\_doctor\_booked\_date\_time** — ускоряет выборку свободных слотов по врачу и времени
* **idx\_appointment\_user\_id**, **idx\_appointment\_doctor\_id** — ускоряют JOIN-ы по внешним ключам
* **idx\_appointment\_user\_date\_time** — ускоряет запрос «мои предстоящие приёмы»

---

## API

### Booking Service

* **GET** `/api/slots/{doctorId}` — список свободных слотов врача
* **POST** `/api/bookings`

  ```json
  {
    "userId": 123,
    "doctorId": 456,
    "slotId": 789
  }
  ```
* **GET** `/api/bookings` — список всех активных записей


### Notification Service

Работает в фоновом режиме, REST-интерфейс отсутствует, результаты — в логах напоминаний.

---
